<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å–µå–µé»é»æ¨‚ï¼šåœ°åœ–æ¨¡å¼æ¶ˆé™¤éŠæˆ²</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* éŠæˆ²å°ˆç”¨è‡ªè¨‚æ¨£å¼ */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c2834; /* æ·±è‰²è–°è¡£è‰ç´«/è— */
            height: 100vh; /* Full viewport height */
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        #game-container {
            width: 100%;
            height: 100vh; /* Full viewport height */
            margin: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* è®“æ¨™é¡Œä½æ–¼é ‚éƒ¨ */
            padding: 1rem; /* é¸å–®æ¨¡å¼ä¸‹çš„å…§é‚Šè· */
            box-sizing: border-box; 
        }

        /* éŠæˆ²æ¨¡å¼ä¸‹çš„å…¨è¢å¹•è¨­å®š */
        #game-container.playing {
            padding: 0; /* ç§»é™¤å…§é‚Šè· */
            justify-content: center; /* è®“å…§å®¹ç½®ä¸­ */
        }

        #game-canvas {
            border: 4px solid #b794f4; /* é‚Šæ¡†ä½¿ç”¨è²“å’ªä¸»é¡Œè‰² (æ·ºç´«) */
            background-color: #f9f7e8; /* æ·ºé»ƒ/ç±³ç™½ï¼Œåƒè²“ç ‚æˆ–å¢Šå­ */
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            touch-action: manipulation; /* ç¦ç”¨ç€è¦½å™¨è§¸æ‘¸æ“ä½œï¼Œæé«˜éŠæˆ²éŸ¿æ‡‰ */
            display: block;
            margin: 0 auto; 
            max-width: 100%;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: bold;
            transition: all 0.2s;
            background-color: #f687b3; /* Pink-400 */
            box-shadow: 0 4px #e53e7a; /* Pink-600 */
            transform: translateY(0);
        }
        .btn:hover {
            opacity: 0.9;
            box-shadow: 0 6px #e53e7a;
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px #e53e7a;
        }

        /* å®Œæˆç•«é¢çš„é¡è‰² */
        .complete-bg {
            background-color: #48bb78; /* ç¶ è‰²ï¼Œè¡¨ç¤ºæˆåŠŸ */
        }
        
        /* å»£å‘Šç‰ˆä½æ¨£å¼ (Placeholder) */
        .ad-slot {
            margin: 1.5rem auto;
            width: 90%;
            max-width: 728px;
            height: 90px;
            background-color: #333;
            color: #ccc;
            border: 2px dashed #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        @media (max-width: 600px) {
             .ad-slot {
                height: 50px;
             }
        }

        /* --- åœ°åœ–æ¨¡å¼ CSS --- */
        #menu-view {
            overflow-x: hidden; 
            overflow-y: scroll; 
            max-height: 80vh; 
            flex-grow: 1; 
        }
        
        #level-map-container {
            position: relative;
            width: 100%;
            min-height: 800px; 
            padding: 2rem 0;
            margin: auto;
        }

        /* è·¯å¾‘ç·š */
        #level-map-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%; 
            transform: translateX(-50%);
            width: 8px; 
            height: 100%;
            background-color: #63b3ed; 
            border-radius: 4px;
            z-index: 10;
        }

        /* é—œå¡ç¯€é» */
        .map-node {
            position: absolute;
            width: 72px;
            height: 72px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            line-height: 1.1;
            cursor: pointer;
            border: 4px solid #fff;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            z-index: 20; 
        }
        
        .map-node:hover:not(.locked) {
            transform: scale(1.15) !important;
            box-shadow: 0 6px 15px rgba(255, 255, 255, 0.4);
        }
        
        .map-node.unlocked {
            background-color: #48bb78; 
            border-color: #f6ad55; 
        }
        .map-node.completed {
            background-color: #38b2ac; 
            border-color: #4c51bf; 
        }
        .map-node.locked {
            background-color: #718096; 
            opacity: 0.6;
            cursor: not-allowed;
            border-color: #4a5568;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(246, 173, 85, 0.7); }
            100% { box-shadow: 0 0 0 15px rgba(246, 173, 85, 0); }
        }
        
        /* ---------------------------------------------------- */
        /* è¨­å‚™æ—‹è½‰æç¤º (Orientation Warning) - JS æ§åˆ¶é¡¯ç¤º/éš±è— */
        /* ---------------------------------------------------- */
        #orientation-warning {
             display: none; 
        }

    </style>
</head>
<body>

    <!-- Orientation Warning Overlay -->
    <div id="orientation-warning" class="fixed inset-0 z-50 bg-gray-900 flex items-center justify-center p-8 text-white text-center">
        <div class="bg-red-600 p-8 rounded-xl shadow-2xl">
            <h2 class="text-3xl font-bold mb-4">è«‹æ—‹è½‰æ‚¨çš„è¨­å‚™ ğŸ”„</h2>
            <p class="text-xl">æ­¤éŠæˆ²åœ¨æ©«å‘æ¨¡å¼ (Landscape) ä¸‹æä¾›æœ€ä½³é«”é©—ã€‚</p>
            <p class="text-lg mt-2">è«‹å°‡æ‰‹æ©Ÿæˆ–å¹³æ¿é›»è…¦æ©«ç½®ã€‚</p>
            <button class="btn bg-white text-red-600 mt-6" onclick="showMenu()">è¿”å›é—œå¡é¸æ“‡</button>
        </div>
    </div>

    <!-- ä¸»éŠæˆ²å®¹å™¨ -->
    <div id="game-container">
        <!-- éŠæˆ²ä¸»æ¨™é¡Œ (åƒ…åœ¨é¸å–®æ¨¡å¼é¡¯ç¤º) -->
        <h1 id="main-title" class="text-4xl font-extrabold text-white mb-6 text-center">ğŸ¾ å–µå–µé»é»æ¨‚ï¼šæ¶ˆé™¤è²“çƒï¼ ğŸ¾</h1>

        <!-- éŠæˆ²ä¸»ä»‹é¢ -->
        <div id="game-screen" class="w-full relative flex-grow flex flex-col items-center justify-center"> 
            <!-- é ‚éƒ¨å»£å‘Šå€å¡Š (åƒ…åœ¨é¸å–®æ¨¡å¼é¡¯ç¤º) -->
            <div id="ad-banner-top" class="ad-slot">
                [æ‚¨çš„å»£å‘Šç¨‹å¼ç¢¼å°‡æ”¾åœ¨æ­¤è™•] - ä¾‹å¦‚ Google AdSense
            </div>
            
            <!-- é—œå¡é¸å–® (åœ°åœ–è¦–åœ–) -->
            <div id="menu-view" class="p-4 bg-gray-800 rounded-xl shadow-2xl w-full max-w-md mx-auto relative">
                <h2 class="text-2xl font-bold text-white mb-4 text-center">ğŸ—ºï¸ é€—è²“åœ°åœ– ğŸ—ºï¸</h2>
                <div id="level-map-container" class="relative">
                    <!-- Map Nodes will be generated here -->
                </div>
            </div>

            <!-- å­é—œå¡é¸å–® (Overlay/Modal) -->
            <div id="sub-level-view" class="hidden absolute inset-0 z-30 bg-gray-900 bg-opacity-90 flex items-center justify-center p-4">
                <div class="bg-gray-700 p-6 rounded-xl shadow-2xl w-full max-w-sm">
                    <h3 id="sub-level-title" class="text-3xl font-bold text-white mb-4 text-center"></h3>
                    <div id="sub-levels-list" class="space-y-3">
                        <!-- Sub-level buttons go here -->
                    </div>
                    <button class="btn w-full text-white mt-6 bg-red-500 shadow-md shadow-red-700 hover:bg-red-600" onclick="hideSubLevelSelection()">è¿”å›åœ°åœ–</button>
                </div>
            </div>

            <!-- éŠæˆ²é€²è¡Œä¸­ç•«é¢ (å…¨è¢å¹•æ¨¡å¼) -->
            <div id="game-view" class="hidden flex-col items-center justify-center flex-grow w-full h-full">
                <!-- éŠæˆ²è³‡è¨Š UI æ¬„ (æœ€å°åŒ–é¡¯ç¤ºåœ¨ç•«å¸ƒä¸Šæ–¹) -->
                <div id="game-info-bar" class="text-white text-xl font-bold mb-3 p-1 rounded-lg bg-gray-900 bg-opacity-50">
                    é—œå¡ <span id="current-level-display">1-1</span> - å‰©é¤˜: 
                    <span id="ball-count">10</span>
                </div>
                <canvas id="game-canvas"></canvas>
            </div>

            <!-- é—œå¡å®Œæˆç•«é¢ (éš±è—ç‹€æ…‹) -->
            <div id="complete-view" class="hidden p-8 complete-bg rounded-xl shadow-2xl text-white text-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <h2 class="text-4xl font-extrabold mb-4">ğŸ‰ è²“å’ªå¤§æ»¿è¶³ï¼ ğŸ‰</h2>
                <p id="completion-message" class="text-xl mb-6">æ‚¨æˆåŠŸé€—æ¨‚äº†æ‰€æœ‰æ¯›ç·šçƒï¼</p>
                <!-- å®Œæˆç•«é¢å°å»£å‘Š -->
                <div id="ad-banner-complete" class="ad-slot h-20 text-sm max-w-sm">
                    [æ‚¨çš„å»£å‘Šç¨‹å¼ç¢¼å°‡æ”¾åœ¨æ­¤è™•] - å®Œæˆç•«é¢
                </div>
                <button class="btn text-white mt-4" onclick="showMenu()">è¿”å›åœ°åœ–</button>
            </div>
        </div>
    </div>

    <script>
        // --- éŠæˆ²ç‹€æ…‹è®Šæ•¸èˆ‡é…ç½® ---
        const STORAGE_KEY = 'catGameProgress_v2';
        // å¢åŠ é»æ“Šå®¹å¿åº¦ï¼Œä»¥æ‡‰å°å¿«é€ŸåŠƒé
        const TOUCH_TOLERANCE = 20; 
        
        let gameState = 'MENU'; 
        let currentLevel = { big: 1, sub: 1, config: null };
        let balls = [];
        let canvas, ctx;
        let animationFrameId;
        let completedLevel = '0-0'; 

        // é—œå¡åœ°åœ–é…ç½®
        const levelMap = {
            1: { 
                theme: "æ¯›ç·šçƒä¸»é¡Œ",
                icon: "ğŸ§¶",
                subLevels: [
                    // 1-1 é—œå¡ï¼šå·¨å‹åŠ é€Ÿ
                    { id: '1-1', balls: 2, speed: 8.0, description: "å·¨å‹æ¥µé€Ÿé›™çƒæŒ‘æˆ° ğŸ’¥" },
                    { id: '1-2', balls: 12, speed: 3.5, description: "è¼•å·§åŠ é€Ÿ" },
                    { id: '1-3', balls: 15, speed: 4.0, description: "æ•¸é‡èˆ‡é€Ÿåº¦" },
                    { id: '1-4', balls: 18, speed: 4.5, description: "æ¥µé™æŒ‘æˆ°" },
                    { id: '1-5', balls: 20, speed: 5.0, description: "è²“çƒå¤§å¸«" }
                ],
                // é«”ç©åŠ å¤§
                radius: { min: 25, max: 40 }, 
                // è—ã€ç¶ ã€é»ƒè‰²èª¿
                colors: ['#4299e1', '#48bb78', '#ecc94b', '#3182ce', '#38a169'] 
            },
            2: { 
                theme: "å°æ˜†èŸ²ä¸»é¡Œ",
                icon: "ğŸ",
                subLevels: [
                    { id: '2-1', balls: 15, speed: 5.5, description: "å—¡å—¡ä½œéŸ¿" },
                    { id: '2-2', balls: 17, speed: 6.0, description: "æ€¥é€Ÿé£›è¡Œ" },
                    { id: '2-3', balls: 20, speed: 6.5, description: "é›£ä»¥æ•æ‰" },
                    { id: '2-4', balls: 22, speed: 7.0, description: "ç¾¤é«”äº‚èˆ" },
                    { id: '2-5', balls: 25, speed: 7.5, description: "æ˜†èŸ²ä¹‹ç‹" }
                ],
                radius: { min: 10, max: 20 },
                colors: ['#48bb78', '#a0aec0', '#d69e2e', '#4299e1']
            },
            3: { 
                theme: "è€é¼ ä¸»é¡Œ",
                icon: "ğŸ­",
                subLevels: [
                    { id: '3-1', balls: 20, speed: 8.0, description: "è§’è½å·è·‘" },
                    { id: '3-2', balls: 25, speed: 8.5, description: "é–ƒé›»ç©¿æ¢­" },
                    { id: '3-3', balls: 30, speed: 9.0, description: "ç„¡å½±ç„¡è¹¤" },
                    { id: '3-4', balls: 35, speed: 9.5, description: "é™·é˜±é å‚™" },
                    { id: '3-5', balls: 40, speed: 10.0, description: "é¼ ç‹é™è‡¨" }
                ],
                radius: { min: 18, max: 30 },
                colors: ['#cbd5e0', '#718096', '#2d3748', '#f56565']
            }
        };

        // --- é€²åº¦ç®¡ç†å‡½æ•¸ (ç•¥) ---

        function loadProgress() {
            try {
                const storedLevel = localStorage.getItem(STORAGE_KEY);
                if (storedLevel && storedLevel !== 'MAX') {
                    completedLevel = storedLevel;
                } else if (storedLevel === 'MAX') {
                    completedLevel = 'MAX'; 
                } else {
                    completedLevel = '0-0'; 
                }
            } catch (e) {
                console.error("ç„¡æ³•è¼‰å…¥é€²åº¦:", e);
                completedLevel = '0-0';
            }
        }

        function saveProgress(levelId) {
             try {
                localStorage.setItem(STORAGE_KEY, levelId);
                completedLevel = levelId;
            } catch (e) {
                console.error("ç„¡æ³•å„²å­˜é€²åº¦:", e);
            }
        }

        function getPreviousLevelId(targetId) {
            const parts = targetId.split('-').map(Number);
            let big = parts[0];
            let sub = parts[1];

            if (sub > 1) {
                return `${big}-${sub - 1}`;
            } else if (big > 1) {
                const prevBigLevelConfig = levelMap[big - 1];
                const lastSub = prevBigLevelConfig ? prevBigLevelConfig.subLevels.length : 5;
                return `${big - 1}-${lastSub}`;
            } else {
                return '0-0'; 
            }
        }

        function isLevelUnlocked(targetId) {
            if (targetId === '1-1') return true; 
            if (completedLevel === 'MAX') return true; 

            const previousId = getPreviousLevelId(targetId);
            return isLevelCompleted(previousId);
        }

        function isLevelCompleted(targetId) {
            if (completedLevel === 'MAX') return true;

            const [targetB, targetS] = targetId.split('-').map(Number);
            const [compB, compS] = completedLevel.split('-').map(Number);
            
            if (compB > targetB) return true;
            if (compB === targetB && compS >= targetS) return true;
            return false;
        }

        // --- è¢å¹•æ—‹è½‰/æ–¹å‘æ§åˆ¶ (ç•¥) ---

        function showOrientationWarning(show) {
            const warning = document.getElementById('orientation-warning');
            if (show) {
                warning.style.display = 'flex';
            } else {
                warning.style.display = 'none';
            }
        }

        function needsRotation() {
            const isSmallScreen = window.innerWidth <= 768 || window.innerHeight <= 768; 
            const isPortrait = window.matchMedia("(orientation: portrait)").matches;
            return isSmallScreen && isPortrait;
        }

        function handleResize() {
            if (gameState === 'PLAYING') {
                if (needsRotation()) {
                    showOrientationWarning(true);
                } else {
                    showOrientationWarning(false);
                    resizeCanvas(); 
                }
            } else {
                showOrientationWarning(false);
            }
        }

        // --- éŠæˆ²ä»‹é¢èˆ‡æµç¨‹å‡½æ•¸ (ç•¥) ---

        function renderLevelMap() {
            const mapContainer = document.getElementById('level-map-container');
            mapContainer.innerHTML = '';
            
            const bigLevelKeys = Object.keys(levelMap).map(Number);
            const TOTAL_BIG_LEVELS = bigLevelKeys.length;
            const VERTICAL_SPACING = 150; 
            const CONTAINER_HEIGHT = TOTAL_BIG_LEVELS * VERTICAL_SPACING + 100; 
            mapContainer.style.height = `${CONTAINER_HEIGHT}px`;

            bigLevelKeys.forEach((big, index) => {
                const firstLevelId = `${big}-1`;
                const isBigLevelUnlocked = isLevelUnlocked(firstLevelId);
                const isBigLevelCompleted = isLevelCompleted(`${big}-${levelMap[big].subLevels.length}`); 
                
                let levelClass = isBigLevelCompleted ? 'completed' : (isBigLevelUnlocked ? 'unlocked' : 'locked');
                const isCurrentNext = isBigLevelUnlocked && !isBigLevelCompleted;
                const positionIndex = (TOTAL_BIG_LEVELS - 1) - index; 
                const top = positionIndex * VERTICAL_SPACING + 20; 
                const isZigZagLeft = index % 2 === 0; 
                const leftPercent = isZigZagLeft ? 20 : 80; 
                const isLevelAccessible = isBigLevelUnlocked || isBigLevelCompleted;

                const nodeContent = `<div class="text-sm">ç¬¬ ${big} å€</div>
                                     <div class="text-3xl">${levelMap[big].icon}</div>
                                     <div class="text-xs font-normal">${levelMap[big].theme}</div>`;

                const pulseStyle = isCurrentNext ? 'animation: pulse 1s infinite alternate;' : '';

                const nodeHtml = `
                    <div 
                        id="big-node-${big}"
                        class="map-node ${levelClass} transform -translate-x-1/2" 
                        style="top: ${top}px; left: ${leftPercent}%; ${pulseStyle}"
                        onclick="${isLevelAccessible ? `showSubLevelSelection(${big})` : ''}"
                        title="${levelMap[big].theme} (${isLevelAccessible ? 'é»æ“Šé¸æ“‡é—œå¡' : 'é–å®š'})"
                    >
                        ${nodeContent}
                    </div>
                `;
                mapContainer.insertAdjacentHTML('beforeend', nodeHtml);
            });

            setTimeout(() => {
                const menuView = document.getElementById('menu-view');
                if (menuView) {
                    menuView.scrollTop = menuView.scrollHeight;
                }
            }, 50);

            if (completedLevel === 'MAX') {
                const endTop = -10;
                const endHtml = `
                    <div class="map-node completed big-icon transform -translate-x-1/2"
                         style="top: ${endTop}px; left: 50%;">
                        <div class="text-3xl">ğŸ†</div>
                        <div class="text-xs">å·²å…¨ç ´</div>
                    </div>
                `;
                mapContainer.insertAdjacentHTML('beforeend', endHtml);
            }
        }

        function showSubLevelSelection(big) {
            const themeConfig = levelMap[big];
            const subView = document.getElementById('sub-level-view');
            const title = document.getElementById('sub-level-title');
            const list = document.getElementById('sub-levels-list');

            title.textContent = `${themeConfig.icon} ç¬¬ ${big} å€ï¼š${themeConfig.theme}`;
            list.innerHTML = '';

            themeConfig.subLevels.forEach(subConfig => {
                const levelId = subConfig.id;
                const unlocked = isLevelUnlocked(levelId);
                const completed = isLevelCompleted(levelId);
                
                let levelClass = completed ? 'bg-teal-500 shadow-teal-700' : 
                                 (unlocked ? 'bg-green-500 shadow-green-700' : 'bg-gray-500 cursor-not-allowed opacity-70 shadow-gray-700');
                
                let levelText = `${levelId}: ${subConfig.description}`;
                if (completed) levelText += ' (âœ” å·²å®Œæˆ)';
                if (!unlocked) levelText += ' (ğŸ”’)';

                const buttonHtml = `
                    <button class="w-full p-3 rounded-lg text-white font-semibold shadow-md transition-all ${levelClass}"
                        onclick="${unlocked || completed ? `startGame(${big}, ${subConfig.id.split('-')[1]});` : ''}"
                        ${unlocked || completed ? '' : 'disabled'}
                    >
                        ${levelText}
                    </button>
                `;
                list.insertAdjacentHTML('beforeend', buttonHtml);
            });

            subView.classList.remove('hidden');
        }

        function hideSubLevelSelection() {
            document.getElementById('sub-level-view').classList.add('hidden');
        }


        function showMenu() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameState = 'MENU';
            
            document.getElementById('game-container').classList.remove('playing');
            document.getElementById('main-title').classList.remove('hidden');
            showOrientationWarning(false); 

            document.getElementById('menu-view').classList.remove('hidden');
            document.getElementById('game-view').classList.add('hidden');
            document.getElementById('complete-view').classList.add('hidden');
            
            document.getElementById('ad-banner-top').classList.remove('hidden');
            document.getElementById('ad-banner-complete').classList.add('hidden');
            hideSubLevelSelection(); 

            renderLevelMap(); 
        }

        function initLevel(config) {
            balls = [];
            const { balls: ballCount, speed: maxSpeed } = config.subConfig;
            const { min: minRadius, max: maxRadius } = config.themeConfig.radius;
            const colors = config.themeConfig.colors;

            document.getElementById('ball-count').textContent = ballCount;
            document.getElementById('current-level-display').textContent = config.subConfig.id;

            for (let i = 0; i < ballCount; i++) {
                // å¦‚æœæ˜¯ 1-1 é—œå¡ï¼Œå¼·åˆ¶ä½¿ç”¨æœ€å¤§åŠå¾‘ï¼Œä»¥ç¢ºä¿å·¨å‹çƒ
                let r = (config.subConfig.id === '1-1') ? maxRadius : (Math.random() * (maxRadius - minRadius) + minRadius);

                const x = Math.random() * (canvas.width - 2 * r) + r;
                const y = Math.random() * (canvas.height - 2 * r) + r;
                const dx = (Math.random() * maxSpeed * 2 - maxSpeed) || (Math.random() > 0.5 ? 0.5 : -0.5); 
                const dy = (Math.random() * maxSpeed * 2 - maxSpeed) || (Math.random() > 0.5 ? 0.5 : -0.5);
                const color = colors[i % colors.length];

                balls.push(new Ball(x, y, r, dx, dy, color));
            }
        }

        function startGame(big, sub) {
            if (needsRotation()) {
                showOrientationWarning(true);
                return; 
            }

            showOrientationWarning(false); 
            
            document.getElementById('game-container').classList.add('playing');
            
            document.getElementById('main-title').classList.add('hidden');
            document.getElementById('ad-banner-top').classList.add('hidden');

            const themeConfig = levelMap[big];
            const subConfig = themeConfig.subLevels[sub - 1];

            currentLevel.big = big;
            currentLevel.sub = sub;
            currentLevel.config = { themeConfig, subConfig };
            gameState = 'PLAYING';
            
            hideSubLevelSelection();

            document.getElementById('menu-view').classList.add('hidden');
            document.getElementById('complete-view').classList.add('hidden');
            document.getElementById('game-view').classList.remove('hidden');

            resizeCanvas(); 
            initLevel(currentLevel.config);
            gameLoop();
        }

        function completeGame() {
            gameState = 'COMPLETE';
            cancelAnimationFrame(animationFrameId);
            
            const currentId = `${currentLevel.big}-${currentLevel.sub}`;
            
            let message = `æ‚¨æˆåŠŸé€—æ¨‚äº†æ‰€æœ‰æ¯›ç·šçƒï¼`;

            if (!isLevelCompleted(currentId)) {
                saveProgress(currentId); 
                const nextId = getNextLevelId(currentId);
                
                if (nextId === 'MAX') {
                    message = 'ğŸ† æ­å–œæ‚¨ï¼æ‰€æœ‰é—œå¡éƒ½å·²å®Œæˆï¼Œæ‚¨æ˜¯æœ€æ£’çš„è²“å’ªå¤§å¸«ï¼ ğŸ†';
                    saveProgress('MAX'); 
                } else {
                    message += ` æ­å–œï¼æ‚¨å·²è§£é–ä¸‹ä¸€é—œ ${nextId}ï¼`;
                }
            } else {
                message += ` (æœ¬é—œå·²é‡è¤‡æŒ‘æˆ°æˆåŠŸ)`;
            }
            
            document.getElementById('completion-message').textContent = message;

            document.getElementById('game-view').classList.add('hidden');
            document.getElementById('complete-view').classList.remove('hidden');
            
            document.getElementById('ad-banner-complete').classList.remove('hidden');
        }

        function getNextLevelId(currentId) {
            const parts = currentId.split('-').map(Number);
            let big = parts[0];
            let sub = parts[1];

            const currentBigLevel = levelMap[big];
            
            if (currentBigLevel && sub < currentBigLevel.subLevels.length) {
                sub++;
                return `${big}-${sub}`;
            } else if (levelMap[big + 1]) {
                big++;
                return `${big}-1`;
            } else {
                return 'MAX';
            }
        }

        // --- æ ¸å¿ƒéŠæˆ²å…ƒä»¶ (Ball Class & Loop) ---

        class Ball {
            constructor(x, y, r, dx, dy, color) {
                this.x = x; 
                this.y = y; 
                this.r = r; 
                this.dx = dx; 
                this.dy = dy; 
                this.color = color; 
                this.isAlive = true;
            }

            draw() {
                if (!this.isAlive) return;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = this.r / 2;
                ctx.fill();
                ctx.closePath();
                
                ctx.shadowBlur = 0; 
                
                ctx.beginPath();
                ctx.arc(this.x + this.r / 3, this.y - this.r / 3, this.r / 3.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fill();
                ctx.closePath();
            }

            update() {
                if (!this.isAlive) return;

                if (this.x + this.r > canvas.width || this.x - this.r < 0) {
                    this.dx = -this.dx;
                    if (this.x + this.r > canvas.width) this.x = canvas.width - this.r;
                    if (this.x - this.r < 0) this.x = this.r;
                }

                if (this.y + this.r > canvas.height || this.y - this.r < 0) {
                    this.dy = -this.dy;
                    if (this.y + this.r > canvas.height) this.y = canvas.height - this.r;
                    if (this.y - this.r < 0) this.y = this.r;
                }

                this.x += this.dx;
                this.y += this.dy;
            }
        }

        function gameLoop() {
            if (gameState !== 'PLAYING') {
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                ball.update();
                ball.draw();
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        /**
         * è™•ç†æ»‘é¼ /è§¸æ‘¸è¼¸å…¥ï¼Œä¸¦å°‡è¢å¹•åº§æ¨™è½‰æ›ç‚º Canvas åº§æ¨™
         * @param {Event} event - æ»‘é¼ æˆ–è§¸æ‘¸äº‹ä»¶
         * @param {boolean} isMove - æ˜¯å¦æ˜¯ touchmove äº‹ä»¶
         */
        function processInput(event, isMove = false) {
            if (gameState !== 'PLAYING' || needsRotation()) return; 
            
            if (event.type === 'touchstart' || event.type === 'touchmove') {
                event.preventDefault(); 
            }

            const touches = event.touches ? Array.from(event.touches) : [{ clientX: event.clientX, clientY: event.clientY }];
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let hitOccurred = false;

            for (const touch of touches) {
                const clientX = touch.clientX;
                const clientY = touch.clientY;

                // ä¿®æ­£ï¼šå°‡è¢å¹•é»æ“Šåº§æ¨™è½‰æ›ç‚º Canvas å…§éƒ¨ç¹ªåœ–åº§æ¨™
                const scaledClickX = (clientX - rect.left) * scaleX;
                const scaledClickY = (clientY - rect.top) * scaleY;

                // å€’åºéæ­·çƒé«”ï¼Œä»¥ä¾¿åœ¨æ¶ˆé™¤å¾Œä¸å½±éŸ¿å¾ªç’°
                for (let i = balls.length - 1; i >= 0; i--) {
                    const ball = balls[i];
                    if (!ball.isAlive) continue;

                    // ä½¿ç”¨è½‰æ›å¾Œçš„åº§æ¨™é€²è¡Œè·é›¢è¨ˆç®—
                    const distance = Math.sqrt(
                        Math.pow(ball.x - scaledClickX, 2) + 
                        Math.pow(ball.y - scaledClickY, 2)
                    );

                    // åˆ¤æ–·æ“Šä¸­ (åŠå¾‘ + å®¹å¿åº¦)
                    if (distance <= ball.r + TOUCH_TOLERANCE) {
                        ball.isAlive = false; 
                        hitOccurred = true;
                        // åŠƒéæ™‚ï¼Œå¯ä»¥ä¸€æ¬¡æ€§æ¶ˆé™¤å¤šå€‹çƒï¼Œæ‰€ä»¥ä¸ä½¿ç”¨ break
                        if (!isMove) {
                            // å¦‚æœæ˜¯å–®æ¬¡é»æ“Šäº‹ä»¶ (mousedown/touchstart/touchend)ï¼Œå‰‡åªæ¶ˆé™¤ä¸€å€‹çƒ
                            break; 
                        }
                    }
                }
            }

            if (hitOccurred) {
                updateBallCountDisplay();
                checkGameCompletion();
            }
        }
        
        function updateBallCountDisplay() {
            const aliveBalls = balls.filter(b => b.isAlive).length;
            document.getElementById('ball-count').textContent = aliveBalls;
        }

        function checkGameCompletion() {
            const remainingBalls = balls.filter(b => b.isAlive).length;
            if (remainingBalls === 0) {
                completeGame();
            }
        }

        // --- åˆå§‹åŒ–èˆ‡ç•«å¸ƒèª¿æ•´ ---

        function setupGame() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            window.addEventListener('resize', handleResize);
            
            // è™•ç†æ»‘é¼ é»æ“Š
            canvas.addEventListener('mousedown', (e) => processInput(e, false));
            
            // è™•ç†è§¸æ‘¸é»æ“Š (å–®é»è§¸æ‘¸)
            canvas.addEventListener('touchstart', (e) => processInput(e, false), { passive: false }); 
            
            // è™•ç†è§¸æ‘¸åŠƒé (æ‹–æ›³)
            canvas.addEventListener('touchmove', (e) => processInput(e, true), { passive: false });
            
            loadProgress(); 
            showMenu(); 
        }

        function resizeCanvas() {
            if (gameState !== 'PLAYING' || needsRotation()) return;

            const ASPECT_RATIO_W = 16;
            const ASPECT_RATIO_H = 9;

            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight; 
            
            const uiBar = document.getElementById('game-info-bar');
            const uiBarHeight = uiBar ? uiBar.offsetHeight + 12 : 20; 

            const maxCanvasHeight = availableHeight - uiBarHeight;
            const maxCanvasWidth = availableWidth;
            
            let finalWidth;
            let finalHeight;

            const heightBasedOnWidth = maxCanvasWidth * (ASPECT_RATIO_H / ASPECT_RATIO_W);

            if (heightBasedOnWidth <= maxCanvasHeight) {
                finalWidth = maxCanvasWidth;
                finalHeight = heightBasedOnWidth;
            } else {
                finalHeight = maxCanvasHeight;
                finalWidth = maxCanvasHeight * (ASPECT_RATIO_W / ASPECT_RATIO_H);
            }

            finalWidth = Math.max(300, Math.floor(finalWidth)); 
            finalHeight = Math.max(168, Math.floor(finalHeight)); 
            
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            
            canvas.width = finalWidth;
            canvas.height = finalHeight;
            
            // é‡æ–°å®šä½çƒé«”
            if (oldWidth > 0 && oldHeight > 0 && balls.length > 0) {
                balls.forEach(ball => {
                    ball.x = ball.x * (finalWidth / oldWidth);
                    ball.y = ball.y * (finalHeight / oldHeight);
                    ball.x = Math.max(ball.r, Math.min(ball.x, finalWidth - ball.r));
                    ball.y = Math.max(ball.r, Math.min(ball.y, finalHeight - ball.r));
                });
            }
        }
        
        window.onload = setupGame;

    </script>
</body>
</html>
