<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å–µå–µé»é»æ¨‚ï¼š3D æ­¡æ¨‚å³¶åœ°åœ–</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ Three.js æ ¸å¿ƒåº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ OrbitControls (ç”¨æ–¼åœ°åœ–æ—‹è½‰å’Œç¸®æ”¾) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* éŠæˆ²å°ˆç”¨è‡ªè¨‚æ¨£å¼ */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c2834; /* æ·±è‰²è–°è¡£è‰ç´«/è— */
            height: 100vh; 
            margin: 0;
            overflow: hidden; 
        }
        #game-container {
            width: 100%;
            height: 100vh; 
            margin: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 1rem;
            box-sizing: border-box; 
        }

        /* éŠæˆ²æ¨¡å¼ä¸‹çš„å…¨è¢å¹•è¨­å®š */
        #game-container.playing {
            padding: 0; 
            justify-content: center; 
        }

        /* 2D éŠæˆ²ç•«å¸ƒ */
        #game-canvas {
            border: 4px solid #b794f4; 
            background-color: #f9f7e8;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            touch-action: manipulation; 
            display: block;
            margin: 0 auto; 
            max-width: 100%;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: bold;
            transition: all 0.2s;
            background-color: #f687b3; /* Pink-400 */
            box-shadow: 0 4px #e53e7a; /* Pink-600 */
            transform: translateY(0);
        }
        .btn:hover {
            opacity: 0.9;
            box-shadow: 0 6px #e53e7a;
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px #e53e7a;
        }

        /* å®Œæˆç•«é¢çš„é¡è‰² */
        .complete-bg {
            background-color: #48bb78; /* ç¶ è‰², è¡¨ç¤ºæˆåŠŸ */
        }
        
        /* --- 3D åœ°åœ–å®¹å™¨ CSS --- */
        #three-container {
            width: 90%;
            max-width: 800px;
            height: 85vh; /* ä¿æŒ 3D æ¸²æŸ“å€åŸŸçš„å°ºå¯¸é™åˆ¶ */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
        }
        
        #three-container canvas {
            display: block;
        }

        /* ---------------------------------------------------- */
        /* è¨­å‚™æ—‹è½‰æç¤º (Orientation Warning) */
        /* ---------------------------------------------------- */
        #orientation-warning {
             display: none; 
        }

    </style>
</head>
<body>

    <!-- Orientation Warning Overlay -->
    <div id="orientation-warning" class="fixed inset-0 z-50 bg-gray-900 flex items-center justify-center p-8 text-white text-center">
        <div class="bg-red-600 p-8 rounded-xl shadow-2xl">
            <h2 class="text-3xl font-bold mb-4">è«‹æ—‹è½‰æ‚¨çš„è¨­å‚™ ğŸ”„</h2>
            <p class="text-xl">æ­¤éŠæˆ²åœ¨æ©«å‘æ¨¡å¼ (Landscape) ä¸‹æä¾›æœ€ä½³é«”é©—ã€‚</p>
            <p class="text-lg mt-2">è«‹å°‡æ‰‹æ©Ÿæˆ–å¹³æ¿é›»è…¦æ©«ç½®ã€‚</p>
            <button class="btn bg-white text-red-600 mt-6" onclick="showMenu()">è¿”å›é—œå¡é¸æ“‡</button>
        </div>
    </div>

    <!-- ä¸»éŠæˆ²å®¹å™¨ -->
    <div id="game-container">
        <!-- éŠæˆ²ä¸»æ¨™é¡Œ (åƒ…åœ¨é¸å–®æ¨¡å¼é¡¯ç¤º) -->
        <h1 id="main-title" class="text-4xl font-extrabold text-white mb-6 text-center">ğŸ¾ å–µå–µé»é»æ¨‚ï¼šæ¶ˆé™¤è²“çƒï¼ ğŸ¾</h1>

        <!-- éŠæˆ²ä¸»ä»‹é¢ -->
        <div id="game-screen" class="w-full relative flex-grow flex flex-col items-center justify-center"> 
            
            <!-- 3D é—œå¡é¸å–® (åœ°åœ–è¦–åœ–) - ä½¿ç”¨ absolute inset-0 ç¢ºä¿å…¨è¦†è“‹ -->
            <div id="menu-view" class="absolute inset-0 flex flex-col items-center justify-center p-4">
                <h2 class="text-3xl font-bold text-white mb-4 rotate-0 text-center absolute top-0 left-1/2 transform -translate-x-1/2 z-20 p-2 rounded-lg bg-gray-900 bg-opacity-50">
                    ğŸ—ºï¸ 3D æ­¡æ¨‚å³¶åœ°åœ– ğŸ—ºï¸
                </h2>
                <div id="three-container">
                    <!-- Three.js Canvas will be appended here -->
                </div>
            </div>

            <!-- å­é—œå¡é¸å–® (Overlay/Modal) -->
            <div id="sub-level-view" class="hidden absolute inset-0 z-30 bg-gray-900 bg-opacity-90 flex items-center justify-center p-4">
                <div class="bg-gray-700 p-6 rounded-xl shadow-2xl w-full max-w-sm">
                    <h3 id="sub-level-title" class="text-3xl font-bold text-white mb-4 rotate-0 text-center"></h3>
                    <div id="sub-levels-list" class="space-y-3">
                        <!-- Sub-level buttons go here -->
                    </div>
                    <!-- FIX: é»æ“ŠæŒ‰éˆ•æ™‚, èª¿ç”¨ showMenu() ç¢ºä¿åœ°åœ–ç‹€æ…‹è¢«æ­£ç¢ºé‡ç½®ä¸¦é¡¯ç¤º -->
                    <button class="btn w-full text-white mt-6 bg-red-500 shadow-md shadow-red-700 hover:bg-red-600" onclick="showMenu()">è¿”å›åœ°åœ–</button>
                </div>
            </div>

            <!-- éŠæˆ²é€²è¡Œä¸­ç•«é¢ (å…¨è¢å¹•æ¨¡å¼) - ä½¿ç”¨ absolute inset-0 ç¢ºä¿å…¨è¦†è“‹ -->
            <div id="game-view" class="hidden absolute inset-0 flex-col items-center justify-center w-full h-full">
                <!-- éŠæˆ²è³‡è¨Š UI æ¬„ (æœ€å°åŒ–é¡¯ç¤ºåœ¨ç•«å¸ƒä¸Šæ–¹) -->
                <div id="game-info-bar" class="text-white text-xl font-bold mb-3 p-1 rounded-lg bg-gray-900 bg-opacity-50">
                    é—œå¡ <span id="current-level-display">1-1</span> - å‰©é¤˜: 
                    <span id="ball-count">10</span>
                </div>
                <canvas id="game-canvas"></canvas>
                <!-- éŠæˆ²æ§åˆ¶æ¢ -->
                <div id="game-controls" class="mt-4">
                    <!-- é€€å‡ºéŠæˆ²æ™‚, è¿”å›è©²ä¸»é¡Œçš„é—œå¡é¸æ“‡ç•«é¢ -->
                    <button class="btn text-white bg-red-500 shadow-md shadow-red-700 hover:bg-red-600" 
                            onclick="returnToThemeLevelSelection()">
                        è¿”å›é—œå¡é¸æ“‡
                    </button>
                </div>
            </div>

            <!-- é—œå¡å®Œæˆç•«é¢ (éš±è—ç‹€æ…‹) -->
            <div id="complete-view" class="hidden p-8 complete-bg rounded-xl shadow-2xl text-white text-center absolute inset-0 z-40 flex flex-col items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <h2 class="text-4xl font-extrabold mb-4">ğŸ‰ è²“å’ªå¤§æ»¿è¶³ï¼ ğŸ‰</h2>
                <p id="completion-message" class="text-xl mb-6">æ‚¨æˆåŠŸé€—æ¨‚äº†æ‰€æœ‰ç›®æ¨™ç‰©ï¼</p>
                <!-- èª¿æ•´æŒ‰éˆ•ä½ˆå±€ä»¥åŒ…å«ä¸‹ä¸€é—œé¸é … -->
                <div class="flex flex-col space-y-4 w-full max-w-xs mx-auto">
                    <!-- ä¸‹ä¸€é—œæŒ‰éˆ• (å‹•æ…‹é¡¯ç¤º/éš±è—) -->
                    <button id="next-level-btn" class="hidden btn text-white bg-blue-500 shadow-md shadow-blue-700 hover:bg-blue-600" onclick="startNextLevel()">ä¸‹ä¸€é—œå¡</button>
                    <!-- å›ä¸»é¡Œé—œå¡æŒ‰éˆ• -->
                    <button id="return-to-map-btn" class="btn text-white bg-pink-500 shadow-md shadow-pink-700 hover:bg-pink-600" onclick="returnToThemeLevelSelection()">å›ä¸»é¡Œé—œå¡</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- éŠæˆ²ç‹€æ…‹è®Šæ•¸èˆ‡é…ç½® ---
        const STORAGE_KEY = 'catGameProgress_v2';
        const TOUCH_TOLERANCE = 20; 
        
        let gameState = 'MENU'; 
        let currentLevel = { big: 1, sub: 1, config: null };
        let balls = [];
        let canvas, ctx;
        let animationFrameId;
        let completedLevel = '0-0'; 
        
        // --- Three.js è®Šæ•¸ ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let mapGroup;
        const LEVEL_NODES_3D = []; // å­˜å„² 3D é—œå¡ç‰©ä»¶ä»¥ä¾¿ Raycasting 

        // é—œå¡åœ°åœ–é…ç½®
        const levelMap = {
            1: { 
                theme: "æ¯›ç·šçƒä¸»é¡Œ",
                icon: "ğŸ§¶",
                subLevels: [
                    { id: '1-1', balls: 1, speed: 6.0, description: "å–®çƒæš–èº« ğŸ‘¶" },
                    { id: '1-2', balls: 3, speed: 8.0, description: "ä¸‰çƒæŒ‘æˆ° ğŸ’ª" },
                    { id: '1-3', balls: 6, speed: 10.0, description: "æ•¸é‡èˆ‡é€Ÿåº¦ ğŸƒ" },
                    { id: '1-4', balls: 8, speed: 12.0, description: "é–ƒé›»å…«çƒ âš¡" },
                    { id: '1-5', balls: 10, speed: 14.0, description: "åçƒå¤§å¸« ğŸ±â€ğŸ" }
                ],
                radius: { min: 25, max: 40 }, 
                colors: ['#4299e1', '#48bb78', '#ecc94b', '#3182ce', '#38a169'] 
            },
            2: { 
                theme: "å°æ˜†èŸ²ä¸»é¡Œ",
                icon: "ğŸ",
                subLevels: [
                    { id: '2-1', balls: 15, speed: 5.5, description: "å—¡å—¡ä½œéŸ¿" },
                    { id: '2-2', balls: 17, speed: 6.0, description: "æ€¥é€Ÿé£›è¡Œ" },
                    { id: '2-3', balls: 20, speed: 6.5, description: "é›£ä»¥æ•æ‰" },
                    { id: '2-4', balls: 22, speed: 7.0, description: "ç¾¤é«”äº‚èˆ" },
                    { id: '2-5', balls: 25, speed: 7.5, description: "æ˜†èŸ²ä¹‹ç‹" }
                ],
                radius: { min: 10, max: 20 },
                colors: ['#48bb78', '#a0aec0', '#d69e2e', '#4299e1']
            },
            3: { 
                theme: "è€é¼ ä¸»é¡Œ",
                icon: "ğŸ­",
                subLevels: [
                    { id: '3-1', balls: 20, speed: 8.0, description: "è§’è½å·è·‘" },
                    { id: '3-2', balls: 25, speed: 8.5, description: "é–ƒé›»ç©¿æ¢­" },
                    { id: '3-3', balls: 30, speed: 9.0, description: "ç„¡å½±ç„¡è¹¤" },
                    { id: '3-4', balls: 35, speed: 9.5, description: "é™·é˜±é å‚™" },
                    { id: '3-5', balls: 40, speed: 10.0, description: "é¼ ç‹é™è‡¨" }
                ],
                radius: { min: 18, max: 30 },
                colors: ['#cbd5e0', '#718096', '#2d3748', '#f56565']
            },
            4: {
                theme: "æ‰“åœ°é¼ ä¸»é¡Œ",
                icon: "ğŸ¹", // å€‰é¼ /åœ°é¼  åœ–ç¤º
                subLevels: [
                    { id: '4-1', balls: 1, speed: 4.0, description: "å–®é¼ æš–èº« ğŸ”¨" },
                    { id: '4-2', balls: 3, speed: 5.0, description: "ä¸‰é¼ å‡ºæ“Š" },
                    { id: '4-3', balls: 5, speed: 6.0, description: "äº”é¼ åœæ”»" },
                    { id: '4-4', balls: 8, speed: 7.0, description: "å…«é¼ ç‹‚å¥”" },
                    { id: '4-5', balls: 12, speed: 8.0, description: "åœ°é¼ ä¹‹ç‹ ğŸ‘‘" }
                ],
                radius: { min: 30, max: 50 }, // è¼ƒå¤§çš„ç›®æ¨™
                colors: ['#8b4513', '#a0522d', '#79553d'] // æ£•è‰²/æ³¥åœŸè‰²
            }
        };

        // --- é€²åº¦ç®¡ç†å‡½æ•¸ (ä¿æŒä¸è®Š) ---
        function loadProgress() {
            try {
                const storedLevel = localStorage.getItem(STORAGE_KEY);
                if (storedLevel && storedLevel !== 'MAX') {
                    completedLevel = storedLevel;
                } else if (storedLevel === 'MAX') {
                    completedLevel = 'MAX'; 
                } else {
                    completedLevel = '0-0'; 
                }
            } catch (e) {
                console.error("ç„¡æ³•è¼‰å…¥é€²åº¦:", e);
                completedLevel = '0-0';
            }
        }

        function saveProgress(levelId) {
             try {
                localStorage.setItem(STORAGE_KEY, levelId);
                completedLevel = levelId;
            } catch (e) {
                console.error("ç„¡æ³•å„²å­˜é€²åº¦:", e);
            }
        }

        function getPreviousLevelId(targetId) {
            const parts = targetId.split('-').map(Number);
            let big = parts[0];
            let sub = parts[1];

            if (sub > 1) {
                return `${big}-${sub - 1}`;
            } else if (big > 1) {
                const prevBigLevelConfig = levelMap[big - 1];
                const lastSub = prevBigLevelConfig ? prevBigLevelConfig.subLevels.length : 5;
                return `${big - 1}-${lastSub}`;
            } else {
                return '0-0'; 
            }
        }
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ä¸‹ä¸€é—œå¡, ä¸¦è¿”å›ä¸‹ä¸€é—œå¡çš„ ID, å¦å‰‡è¿”å› 'MAX'
        function getNextLevelId(currentId) {
            const parts = currentId.split('-').map(Number);
            let big = parts[0];
            let sub = parts[1];

            const currentBigLevel = levelMap[big];
            
            // æª¢æŸ¥ç•¶å‰å¤§é—œå¡æ˜¯å¦æœ‰ä¸‹ä¸€å°é—œ
            if (currentBigLevel && sub < currentBigLevel.subLevels.length) {
                sub++;
                return `${big}-${sub}`;
            } 
            // æª¢æŸ¥æ˜¯å¦æœ‰ä¸‹ä¸€å€‹å¤§é—œå¡
            else if (levelMap[big + 1]) {
                big++;
                return `${big}-1`;
            } 
            // æ²’æœ‰ä¸‹ä¸€é—œäº†
            else {
                return 'MAX';
            }
        }

        function isLevelUnlocked(targetId) {
            if (targetId === '1-1') return true; 
            if (completedLevel === 'MAX') return true; 

            const previousId = getPreviousLevelId(targetId);
            return isLevelCompleted(previousId);
        }

        function isLevelCompleted(targetId) {
            if (completedLevel === 'MAX') return true;

            const [targetB, targetS] = targetId.split('-').map(Number);
            const [compB, compS] = completedLevel.split('-').map(Number);
            
            if (compB > targetB) return true;
            if (compB === targetB && compS >= targetS) return true;
            return false;
        }

        // --- è¢å¹•æ—‹è½‰/æ–¹å‘æ§åˆ¶ (ä¿æŒä¸è®Š) ---

        function showOrientationWarning(show) {
            const warning = document.getElementById('orientation-warning');
            if (show) {
                warning.style.display = 'flex';
            } else {
                warning.style.display = 'none';
            }
        }

        function needsRotation() {
            const isSmallScreen = window.innerWidth <= 768 || window.innerHeight <= 768; 
            const isPortrait = window.matchMedia("(orientation: portrait)").matches;
            return isSmallScreen && isPortrait;
        }

        function handleResize() {
            if (gameState === 'PLAYING') {
                if (needsRotation()) {
                    showOrientationWarning(true);
                } else {
                    showOrientationWarning(false);
                    resizeCanvas(); 
                }
            } else if (gameState === 'MENU') {
                // èª¿æ•´ 3D æ¸²æŸ“å™¨å¤§å°
                const container = document.getElementById('three-container');
                if (renderer && container) {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    camera.aspect = width / height;
                    // ä¿®æ­£éŒ¯èª¤ï¼šä½¿ç”¨æ­£ç¢ºçš„ Three.js æ–¹æ³•åç¨±
                    camera.updateProjectionMatrix(); 
                    renderer.setSize(width, height);
                }
            }
        }

        // --- 3D åœ°åœ–åˆå§‹åŒ–èˆ‡æ¸²æŸ“ ---
        function initThreeScene() {
            const container = document.getElementById('three-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // 1. å ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // å¤©ç©ºè—

            // 2. æ”å½±æ©Ÿ
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 50, 50); // æŠ¬é«˜ä¸¦ç¨å¾®é è¿‘

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // å•Ÿç”¨é™°å½±
            container.appendChild(renderer.domElement);

            // 4. æ§åˆ¶å™¨ (è»Œé“æ§åˆ¶)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // å•Ÿç”¨é˜»å°¼æ•ˆæœ
            controls.dampingFactor = 0.05;
            controls.minDistance = 30;
            controls.maxDistance = 150;
            controls.target.set(0, 0, 0); // é–å®šä¸­å¿ƒ

            // 5. å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // ç’°å¢ƒå…‰
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // æ–¹å‘å…‰
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // 6. 3D ç‰©ä»¶ç¾¤çµ„
            mapGroup = new THREE.Group();
            scene.add(mapGroup);
            
            // 7. è¨­ç½®å³¶å¶¼åŸºåº•
            createIslandBase();

            // 8. æ·»åŠ äº‹ä»¶ç›£è½
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('click', onMapNodeClick, false);
            
            // 9. å»ºç«‹åœ°åœ–ç¯€é»
            createLevelNodes3D();
            
            // 10. é–‹å§‹æ¸²æŸ“å¾ªç’°
            animateThreeScene();
        }
        
        function createIslandBase() {
            // å³¶å¶¼åŸºåº• (æ·ºç¶ è‰²/æ³¥åœŸè‰²)
            const islandGeometry = new THREE.CylinderGeometry(40, 60, 10, 32); 
            const islandMaterial = new THREE.MeshPhongMaterial({ color: 0x90EE90, shininess: 5 }); // Light Green
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.position.y = -5;
            island.receiveShadow = true;
            mapGroup.add(island);

            // æ°´é¢ (è—è‰²)
            const waterGeometry = new THREE.CircleGeometry(150, 32);
            const waterMaterial = new THREE.MeshBasicMaterial({ color: 0x4fc3f7, transparent: true, opacity: 0.8 });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -10;
            scene.add(water);
        }

        // --- å‰µå»ºç°¡æ½”çš„ 3D çƒé«”ç¯€é» ---
        function createLevelNodes3D() {
            // æ¸…ç©ºèˆŠçš„ç¯€é»
            LEVEL_NODES_3D.length = 0;
            // ç§»é™¤æ‰€æœ‰æ¨™è¨˜ç‚º isLevelNode çš„ç‰©ä»¶
            mapGroup.children.filter(c => c.userData.isLevelNode).forEach(c => mapGroup.remove(c));

            const bigLevelKeys = Object.keys(levelMap).map(Number);
            const TOTAL_BIG_LEVELS = bigLevelKeys.length;
            const VERTICAL_SPACING_3D = 20; // Z è»¸é–“éš”
            const HORIZONTAL_OFFSET = 10; // X è»¸åç§»é‡
            const nodeSize = 3; 

            // å®šç¾©æ¯å€‹å¤§é—œå¡çš„ä¸»é¡Œè‰² (å·²è§£é–ç‹€æ…‹)
            const themeColors = {
                1: 0x4299e1, // è—è‰² (æ¯›ç·šçƒ)
                2: 0x48bb78, // ç¶ è‰² (å°æ˜†èŸ²)
                3: 0xa0aec0, // æ·ºç°è‰² (è€é¼ )
                4: 0xd69e2e  // é»ƒæ£•è‰² (æ‰“åœ°é¼ )
            };
            const completedColor = 0x38b2ac; // é’è‰² (å·²å®Œæˆ)
            const lockedColor = 0x718096;    // æ·±ç°è‰² (é–å®š)
            
            let lastPosition = new THREE.Vector3(0, 0, 0);

            bigLevelKeys.forEach((big, index) => {
                const isZigZagLeft = index % 2 === 0; 
                const positionIndex = (TOTAL_BIG_LEVELS - 1) - index; 
                
                // å®šä½ï¼šX è»¸å·¦å³äº¤éŒ¯, Y è»¸åœ¨å³¶å¶¼ä¸Š, Z è»¸å¾å¾Œå¾€å‰
                const x = isZigZagLeft ? -HORIZONTAL_OFFSET : HORIZONTAL_OFFSET;
                const y = 5; 
                const z = positionIndex * VERTICAL_SPACING_3D;
                const nodePosition = new THREE.Vector3(x, y, z);
                
                // ç¹ªè£½è·¯å¾‘ç·š
                if (index > 0) {
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x63b3ed, linewidth: 5 });
                    const points = [];
                    points.push(lastPosition);
                    points.push(nodePosition);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    mapGroup.add(line);
                }
                lastPosition = nodePosition;

                // æª¢æŸ¥é—œå¡ç‹€æ…‹
                const isCompleted = isLevelCompleted(`${big}-${levelMap[big].subLevels.length}`);
                const isUnlocked = isLevelUnlocked(`${big}-1`);
                
                // ç¢ºå®šç¯€é»é¡è‰²
                let nodeColorHex;
                if (isCompleted) {
                    nodeColorHex = completedColor;
                } else if (isUnlocked) {
                    nodeColorHex = themeColors[big] || 0x4299e1; // ä½¿ç”¨ä¸»é¡Œè‰²
                } else {
                    nodeColorHex = lockedColor;
                }

                // å‰µå»ºçµ±ä¸€çš„çƒé«”å¹¾ä½•å’Œæè³ª
                const geometry = new THREE.SphereGeometry(nodeSize * 1.5, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color: nodeColorHex, 
                    shininess: 50,
                    specular: 0x555555 
                });
                
                const themeMesh = new THREE.Mesh(geometry, material);
                themeMesh.position.copy(nodePosition);
                themeMesh.castShadow = true; 

                // å„²å­˜é—œå¡æ•¸æ“šåˆ° userData (ç”¨æ–¼ Raycasting è­˜åˆ¥)
                themeMesh.userData = { 
                    bigLevel: big,
                    isLevelNode: true, // æ¨™è¨˜ç‚ºå¯é»æ“Šç¯€é»
                    isUnlocked: isUnlocked,
                    isCompleted: isCompleted,
                    isRotatable: (big === 1) // è®“æ¯›ç·šçƒ (L1) ç¯€é»ä»ç„¶å¯ä»¥æ—‹è½‰
                };

                mapGroup.add(themeMesh);
                LEVEL_NODES_3D.push(themeMesh);
            });
            
            // å°‡æ•´å€‹åœ°åœ–ä¸­å¿ƒç§»è‡³ Z=0 (ä½¿å…¶åœ¨è¢å¹•ä¸­å¿ƒ)
            mapGroup.position.z = -((TOTAL_BIG_LEVELS - 1) * VERTICAL_SPACING_3D) / 2;
        }

        function animateThreeScene() {
            animationFrameId = requestAnimationFrame(animateThreeScene);
            if (gameState !== 'MENU') return;

            // æ›´æ–°æ§åˆ¶å™¨
            controls.update(); 

            // è®“ Level 1 (æ¯›ç·šçƒ) çš„çƒé«”å¾®å¾®æ—‹è½‰
            LEVEL_NODES_3D.forEach(node => {
                if (node.userData.isRotatable) {
                    node.rotation.y += 0.005;
                }
            });

            // æ¸²æŸ“
            renderer.render(scene, camera);
        }

        function onMapNodeClick(event) {
            if (gameState !== 'MENU') return;

            event.preventDefault();

            const container = document.getElementById('three-container');
            const rect = container.getBoundingClientRect();
            
            // å°‡æ»‘é¼ åº§æ¨™è½‰æ›ç‚º Three.js çš„æ¨™æº–åŒ–è¨­å‚™åº§æ¨™ (NDC)
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // é€é Raycaster æª¢æŸ¥é»æ“Šäº†å“ªå€‹ç‰©ä»¶ (éè¿´æª¢æŸ¥æ‰€æœ‰å­ç‰©ä»¶)
            raycaster.setFromCamera(mouse, camera);
            
            // ç›´æ¥æª¢æŸ¥ LEVEL_NODES_3D æ•¸çµ„ä¸­çš„ Mesh
            const intersects = raycaster.intersectObjects(LEVEL_NODES_3D, false);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                
                if (clickedObject.userData.isLevelNode) {
                    const bigLevel = clickedObject.userData.bigLevel;
                    const isUnlocked = clickedObject.userData.isUnlocked;

                    if (isUnlocked) {
                        // å¦‚æœé—œå¡å·²è§£é–, é¡¯ç¤ºå­é—œå¡é¸å–®
                        showSubLevelSelection(bigLevel);
                    } else {
                        // é–å®šæç¤º
                        console.log(`é—œå¡ ${bigLevel} é–å®šä¸­!`);
                    }
                }
            }
        }


        // --- éŠæˆ²ä»‹é¢èˆ‡æµç¨‹å‡½æ•¸ (ä¿æŒä¸è®Š) ---

        function showSubLevelSelection(big) {
            const themeConfig = levelMap[big];
            const subView = document.getElementById('sub-level-view');
            const title = document.getElementById('sub-level-title');
            const list = document.getElementById('sub-levels-list');

            title.textContent = `${themeConfig.icon} ç¬¬ ${big} å€ï¼š${themeConfig.theme}`;
            list.innerHTML = '';

            themeConfig.subLevels.forEach(subConfig => {
                const levelId = subConfig.id;
                const unlocked = isLevelUnlocked(levelId);
                const completed = isLevelCompleted(levelId);
                
                let levelClass = completed ? 'bg-teal-500 shadow-teal-700' : 
                                 (unlocked ? 'bg-green-500 shadow-green-700' : 'bg-gray-500 cursor-not-allowed opacity-70 shadow-gray-700');
                
                let levelText = `${levelId}: ${subConfig.description}`;
                if (completed) levelText += ' (âœ” å·²å®Œæˆ)';
                if (!unlocked) levelText += ' (ğŸ”’)';

                const buttonHtml = `
                    <button class="w-full p-3 rounded-lg text-white font-semibold shadow-md transition-all ${levelClass}"
                        onclick="${unlocked || completed ? `startGame(${big}, ${subConfig.id.split('-')[1]});` : ''}"
                        ${unlocked || completed ? '' : 'disabled'}
                    >
                        ${levelText}
                    </button>
                `;
                list.insertAdjacentHTML('beforeend', buttonHtml);
            });

            subView.classList.remove('hidden');
        }

        function hideSubLevelSelection() {
            document.getElementById('sub-level-view').classList.add('hidden');
        }


        function showMenu() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameState = 'MENU';
            
            document.getElementById('game-container').classList.remove('playing');
            document.getElementById('main-title').classList.remove('hidden');
            showOrientationWarning(false); 

            // ç¢ºä¿åªé¡¯ç¤ºé¸å–®, ä¸¦éš±è—å…¶ä»–è¦–åœ–
            document.getElementById('menu-view').classList.remove('hidden');
            document.getElementById('game-view').classList.add('hidden');
            document.getElementById('complete-view').classList.add('hidden');
            
            hideSubLevelSelection(); // éš±è—å­é—œå¡é¸å–®

            // å•Ÿå‹• 3D å ´æ™¯
            if (!renderer) {
                initThreeScene();
            } else {
                animateThreeScene();
                createLevelNodes3D(); // é‡æ–°æ¸²æŸ“ç¯€é»ç‹€æ…‹
            }
            handleResize();
        }
        
        // ** è¿”å›ç•¶å‰ä¸»é¡Œé—œå¡é¸å–®çš„å‡½æ•¸ **
        function returnToThemeLevelSelection() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            gameState = 'MENU';
            document.getElementById('game-container').classList.remove('playing');
            document.getElementById('game-view').classList.add('hidden');
            document.getElementById('complete-view').classList.add('hidden');
            document.getElementById('main-title').classList.remove('hidden');
            showOrientationWarning(false);

            if (!renderer) {
                initThreeScene();
            } else {
                animateThreeScene();
                createLevelNodes3D(); 
            }

            showSubLevelSelection(currentLevel.big);
        }


        // ** æ›´æ–°ï¼šç›´æ¥é–‹å§‹ä¸‹ä¸€é—œçš„å‡½æ•¸ **
        function startNextLevel() {
            const currentId = `${currentLevel.big}-${currentLevel.sub}`;
            const nextId = getNextLevelId(currentId);

            if (nextId === 'MAX') {
                showMenu(); 
                return;
            }

            const [big, sub] = nextId.split('-').map(Number);
            
            document.getElementById('complete-view').classList.add('hidden');
            
            startGame(big, sub);
        }

        // ** æ›´æ–°ï¼šé—œå¡å®Œæˆå‡½æ•¸, è™•ç†é€²åº¦å’ŒæŒ‰éˆ•é¡¯ç¤º **
        function completeGame() {
            gameState = 'COMPLETE';
            cancelAnimationFrame(animationFrameId);
            
            const currentId = `${currentLevel.big}-${currentLevel.sub}`;
            const nextId = getNextLevelId(currentId);
            
            let message = `æ‚¨æˆåŠŸé€—æ¨‚äº†æ‰€æœ‰ç›®æ¨™ç‰©ï¼`;
            
            // 1. å„²å­˜é€²åº¦
            if (!isLevelCompleted(currentId)) {
                saveProgress(currentId); 
            }
            
            // 2. è¨­å®šæŒ‰éˆ•å’Œè¨Šæ¯
            const nextLevelBtn = document.getElementById('next-level-btn');
            
            if (nextId === 'MAX') {
                // å¦‚æœæ²’æœ‰ä¸‹ä¸€é—œäº†
                message = 'ğŸ† æ­å–œæ‚¨ï¼æ‰€æœ‰é—œå¡éƒ½å·²å®Œæˆ, æ‚¨æ˜¯æœ€æ£’çš„è²“å’ªå¤§å¸«ï¼ ğŸ†';
                saveProgress('MAX'); 
                nextLevelBtn.classList.add('hidden');
            } else {
                // å¦‚æœæœ‰ä¸‹ä¸€é—œ
                message += ` æ­å–œï¼æ‚¨å·²è§£é–ä¸‹ä¸€é—œ ${nextId}ï¼`;
                nextLevelBtn.textContent = `ä¸‹ä¸€é—œå¡ ${nextId}`;
                nextLevelBtn.classList.remove('hidden');
            }

            document.getElementById('completion-message').textContent = message;

            // 3. é¡¯ç¤ºå®Œæˆç•«é¢
            document.getElementById('game-view').classList.add('hidden');
            document.getElementById('complete-view').classList.remove('hidden');
        }

        // --- æ ¸å¿ƒéŠæˆ²å…ƒä»¶ (Ball Class & Loop) ---

        function initLevel(config) {
            balls = [];
            const { balls: ballCount, speed: maxSpeed } = config.subConfig;
            const { min: minRadius, max: maxRadius } = config.themeConfig.radius;
            const colors = config.themeConfig.colors;

            document.getElementById('ball-count').textContent = ballCount;
            document.getElementById('current-level-display').textContent = config.subConfig.id;

            for (let i = 0; i < ballCount; i++) {
                let r = Math.random() * (maxRadius - minRadius) + minRadius;

                const x = Math.random() * (canvas.width - 2 * r) + r;
                const y = Math.random() * (canvas.height - 2 * r) + r;
                // é€Ÿåº¦ç¯„åœç¾åœ¨ç”± maxSpeed æ±ºå®š
                const dx = (Math.random() * maxSpeed * 2 - maxSpeed) || (Math.random() > 0.5 ? 0.5 : -0.5); 
                const dy = (Math.random() * maxSpeed * 2 - maxSpeed) || (Math.random() > 0.5 ? 0.5 : -0.5);
                const color = colors[i % colors.length];

                balls.push(new Ball(x, y, r, dx, dy, color));
            }
        }

        function startGame(big, sub) {
            if (needsRotation()) {
                showOrientationWarning(true);
                return; 
            }

            // åœæ­¢ 3D æ¸²æŸ“å¾ªç’°
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            showOrientationWarning(false); 
            
            document.getElementById('game-container').classList.add('playing');
            
            document.getElementById('main-title').classList.add('hidden');
            
            const themeConfig = levelMap[big];
            const subConfig = themeConfig.subLevels[sub - 1];

            currentLevel.big = big;
            currentLevel.sub = sub;
            currentLevel.config = { themeConfig, subConfig };
            gameState = 'PLAYING';
            
            hideSubLevelSelection();

            // ç¢ºä¿åªé¡¯ç¤ºéŠæˆ²ç•«é¢, ä¸¦éš±è—å…¶ä»–è¦–åœ–
            document.getElementById('menu-view').classList.add('hidden');
            document.getElementById('complete-view').classList.add('hidden');
            document.getElementById('game-view').classList.remove('hidden');

            resizeCanvas(); 
            initLevel(currentLevel.config);
            gameLoop();
        }

        class Ball {
            constructor(x, y, r, dx, dy, color) {
                this.x = x; 
                this.y = y; 
                this.r = r; 
                this.dx = dx; 
                this.dy = dy; 
                this.color = color; 
                this.isAlive = true;
            }

            draw() {
                if (!this.isAlive) return;

                const bigLevel = currentLevel.big;
                
                // è¨­å®šé™°å½±
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = this.r / 3;

                if (bigLevel === 2) {
                    // --- Insect Drawing (Theme 2: å°æ˜†èŸ²ä¸»é¡Œ) ---
                    // ä¿æŒ 2D æ˜†èŸ²é€ å‹ä¸è®Š
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const bodyRadius = this.r * 0.8;
                    const headRadius = this.r * 0.4;

                    // Body (Oval/Circle)
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bodyRadius, this.r, 0, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.closePath();
                    
                    // Center line (Ladybug-like)
                    ctx.beginPath();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.moveTo(0, -this.r);
                    ctx.lineTo(0, this.r);
                    ctx.stroke();
                    
                    // Head (Black circle)
                    ctx.beginPath();
                    ctx.arc(0, -this.r * 0.8, headRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#000000';
                    ctx.fill();
                    ctx.closePath();

                    // Eyes (White dots)
                    const eyeRadius = headRadius * 0.2;
                    ctx.beginPath();
                    ctx.arc(headRadius * 0.3, -this.r * 0.9, eyeRadius, 0, Math.PI * 2);
                    ctx.arc(-headRadius * 0.3, -this.r * 0.9, eyeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill();
                    ctx.closePath();
                    
                    ctx.restore();
                    
                } else if (bigLevel === 3) {
                    // --- Mouse Drawing (Theme 3: è€é¼ ä¸»é¡Œ) ---
                    // ä¿æŒ 2D è€é¼ é€ å‹ä¸è®Š
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const earRadius = this.r * 0.35;
                    const bodyColor = this.color;
                    const earColor = '#ffffff'; 
                    const innerEarColor = '#f56565'; // Pink

                    // Body
                    ctx.beginPath();
                    ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                    ctx.fillStyle = bodyColor;
                    ctx.fill();
                    ctx.closePath();
                    
                    // Ears (Circles for simplicity)
                    const earOffsetX = this.r * 0.6;
                    const earOffsetY = this.r * 0.6;

                    // Left Outer Ear
                    ctx.beginPath();
                    ctx.arc(-earOffsetX, -earOffsetY, earRadius, 0, Math.PI * 2);
                    ctx.fillStyle = earColor;
                    ctx.fill();
                    
                    // Left Inner Ear
                    ctx.beginPath();
                    ctx.arc(-earOffsetX, -earOffsetY, earRadius * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = innerEarColor;
                    ctx.fill();

                    // Right Outer Ear
                    ctx.beginPath();
                    ctx.arc(earOffsetX, -earOffsetY, earRadius, 0, Math.PI * 2);
                    ctx.fillStyle = earColor;
                    ctx.fill();
                    
                    // Right Inner Ear
                    ctx.beginPath();
                    ctx.arc(earOffsetX, -earOffsetY, earRadius * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = innerEarColor;
                    ctx.fill();

                    // Eyes
                    const eyeRadius = this.r * 0.1;
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-this.r * 0.3, -this.r * 0.1, eyeRadius, 0, Math.PI * 2);
                    ctx.arc(this.r * 0.3, -this.r * 0.1, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                } else if (bigLevel === 4) {
                    // --- Mole Drawing (Theme 4: æ‰“åœ°é¼ ä¸»é¡Œ) ---
                    // ä¿æŒ 2D åœ°é¼ é€ å‹ä¸è®Š
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const headRadius = this.r;
                    const noseRadius = this.r * 0.15;
                    const eyeRadius = this.r * 0.1;

                    // Body/Head (Brown circle)
                    ctx.beginPath();
                    ctx.arc(0, 0, headRadius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color; // åœ°é¼ èº«é«”é¡è‰²
                    ctx.fill();
                    ctx.closePath();

                    // Ears (Simple circles)
                    const earSize = this.r * 0.3;
                    ctx.fillStyle = '#69472e'; // æ·±æ£•è‰²è€³æœµ
                    
                    ctx.beginPath();
                    ctx.arc(-headRadius * 0.6, -headRadius * 0.6, earSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    
                    ctx.beginPath();
                    ctx.arc(headRadius * 0.6, -headRadius * 0.6, earSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Nose (Pink)
                    ctx.beginPath();
                    ctx.arc(0, headRadius * 0.3, noseRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#f687b3'; // ç²‰ç´…è‰²é¼»å­
                    ctx.fill();
                    ctx.closePath();

                    // Eyes (Black)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-headRadius * 0.3, -headRadius * 0.1, eyeRadius, 0, Math.PI * 2);
                    ctx.arc(headRadius * 0.3, -headRadius * 0.1, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    
                    ctx.restore();

                } else {
                    // --- Yarn Ball Drawing (Theme 1: æ¯›ç·šçƒä¸»é¡Œ) - Original Drawing ---
                    // ä¿æŒ 2D æ¯›ç·šçƒé€ å‹ä¸è®Š
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    ctx.closePath();
                    
                    // Highlight
                    ctx.shadowBlur = 0; // é—œé–‰é™°å½±ä»¥å…å½±éŸ¿é«˜å…‰
                    ctx.beginPath();
                    ctx.arc(this.x + this.r / 3, this.y - this.r / 3, this.r / 3.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fill();
                    ctx.closePath();
                }
                
                // é‡ç½®é™°å½±
                ctx.shadowBlur = 0; 
            }

            update() {
                if (!this.isAlive) return;

                if (this.x + this.r > canvas.width || this.x - this.r < 0) {
                    this.dx = -this.dx;
                    if (this.x + this.r > canvas.width) this.x = canvas.width - this.r;
                    if (this.x - this.r < 0) this.x = this.r;
                }

                if (this.y + this.r > canvas.height || this.y - this.r < 0) {
                    this.dy = -this.dy;
                    if (this.y + this.r > canvas.height) this.y = canvas.height - this.r;
                    if (this.y - this.r < 0) this.y = this.r;
                }

                this.x += this.dx;
                this.y += this.dy;
            }
        }

        function gameLoop() {
            if (gameState !== 'PLAYING') {
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                ball.update();
                ball.draw();
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function processInput(event, isMove = false) {
            if (gameState !== 'PLAYING' || needsRotation()) return; 
            
            if (event.type === 'touchstart' || event.type === 'touchmove') {
                event.preventDefault(); 
            }

            const touches = event.touches ? Array.from(event.touches) : [{ clientX: event.clientX, clientY: event.clientY }];
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let hitOccurred = false;

            for (const touch of touches) {
                const clientX = touch.clientX;
                const clientY = touch.clientY;

                const scaledClickX = (clientX - rect.left) * scaleX;
                const scaledClickY = (clientY - rect.top) * scaleY;

                for (let i = balls.length - 1; i >= 0; i--) {
                    const ball = balls[i];
                    if (!ball.isAlive) continue;

                    // å¢åŠ è§¸æ‘¸å®¹å¿åº¦, ä»¥é©æ‡‰è¤‡é›œå½¢ç‹€å’Œæ‰‹æŒ‡é»æ“Š
                    const targetRadius = ball.r + TOUCH_TOLERANCE; 
                    const distance = Math.sqrt(
                        Math.pow(ball.x - scaledClickX, 2) + 
                        Math.pow(ball.y - scaledClickY, 2)
                    );

                    // æª¢æŸ¥è·é›¢æ˜¯å¦åœ¨åŠå¾‘ç¯„åœå…§
                    if (distance <= targetRadius) {
                        ball.isAlive = false; 
                        hitOccurred = true;
                        if (!isMove) {
                            break; 
                        }
                    }
                }
            }

            if (hitOccurred) {
                updateBallCountDisplay();
                checkGameCompletion();
            }
        }
        
        function updateBallCountDisplay() {
            const aliveBalls = balls.filter(b => b.isAlive).length;
            document.getElementById('ball-count').textContent = aliveBalls;
        }

        function checkGameCompletion() {
            const remainingBalls = balls.filter(b => b.isAlive).length;
            if (remainingBalls === 0) {
                completeGame();
            }
        }

        // --- åˆå§‹åŒ–èˆ‡ç•«å¸ƒèª¿æ•´ (ä¿æŒä¸è®Š) ---

        function setupGame() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            window.addEventListener('resize', handleResize);
            
            // 2D éŠæˆ²è¼¸å…¥
            canvas.addEventListener('mousedown', (e) => processInput(e, false));
            canvas.addEventListener('touchstart', (e) => processInput(e, false), { passive: false }); 
            canvas.addEventListener('touchmove', (e) => processInput(e, true), { passive: false });
            
            loadProgress(); 
            showMenu(); 
        }

        function resizeCanvas() {
            if (gameState !== 'PLAYING' || needsRotation()) return;

            const ASPECT_RATIO_W = 16;
            const ASPECT_RATIO_H = 9;

            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight; 
            
            const uiBar = document.getElementById('game-info-bar');
            const controlsBar = document.getElementById('game-controls');

            // è¨ˆç®— UI æ¬„ä½ç¸½é«˜åº¦ (ä¸Šæ–¹ info-bar + ä¸‹æ–¹ controls-bar + é–“è·)
            const uiHeight = (uiBar ? uiBar.offsetHeight : 0) + 
                             (controlsBar ? controlsBar.offsetHeight : 0) + 
                             20; // é¡å¤–é–“è·
            
            const maxCanvasHeight = availableHeight - uiHeight;
            const maxCanvasWidth = availableWidth;
            
            let finalWidth;
            let finalHeight;

            const heightBasedOnWidth = maxCanvasWidth * (ASPECT_RATIO_H / ASPECT_RATIO_W);

            if (heightBasedOnWidth <= maxCanvasHeight) {
                finalWidth = maxCanvasWidth;
                finalHeight = heightBasedOnWidth;
            } else {
                finalHeight = maxCanvasHeight;
                finalWidth = maxCanvasHeight * (ASPECT_RATIO_W / ASPECT_RATIO_H);
            }

            finalWidth = Math.max(300, Math.floor(finalWidth)); 
            finalHeight = Math.max(168, Math.floor(finalHeight)); 
            
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            
            canvas.width = finalWidth;
            canvas.height = finalHeight;
            
            // é‡æ–°å®šä½çƒé«”
            if (oldWidth > 0 && oldHeight > 0 && balls.length > 0) {
                balls.forEach(ball => {
                    ball.x = ball.x * (finalWidth / oldWidth);
                    ball.y = ball.y * (finalHeight / oldHeight);
                    ball.x = Math.max(ball.r, Math.min(ball.x, finalWidth - ball.r));
                    ball.y = Math.max(ball.r, Math.min(ball.y, finalHeight - ball.r));
                });
            }
        }
        
        window.onload = setupGame;

    </script>
</body>
</html>
